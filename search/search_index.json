{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Registerer Sometimes you may want to use a string to identify a specific function or class. This is a common way of designing your code, but it can be tricky to do it without repeating yourself. Registerer is a tool that helps you to do this easily, and also makes sure that your code is explicit and type safe. TLDR Write this: import registerer command_handler_registry = registerer . Registerer () @command_handler_registry . register () def info ( args ): return \"how can i help you?\" @command_handler_registry . register () def play ( args ): return \"let me play a song for you\" command = \"info\" args = {} assert command_handler_registry [ command ]( args ) == \"how can i help you?\" Instead of this, which violates the Open-Closed Principle (OCP): def info ( args ): return \"how can i help you?\" def play ( args ): return \"let me play a song for you\" def command_handler ( command , args ): if command == \"info\" : return info ( args ) if command == \"play\" : return play ( args ) command = \"play\" args = {} assert command_handler ( command , args ) == \"let me play a song for you\" Installation You can install the latest version of registerer from PyPI: pip install registerer Features It's completely type-safe, thus you will get suggestions from your IDE. Writing custom validations for registered items is provided without any inheritance. generate choices for Django from registered items. And so on...","title":"Overview"},{"location":"#registerer","text":"Sometimes you may want to use a string to identify a specific function or class. This is a common way of designing your code, but it can be tricky to do it without repeating yourself. Registerer is a tool that helps you to do this easily, and also makes sure that your code is explicit and type safe.","title":"Registerer"},{"location":"#tldr","text":"Write this: import registerer command_handler_registry = registerer . Registerer () @command_handler_registry . register () def info ( args ): return \"how can i help you?\" @command_handler_registry . register () def play ( args ): return \"let me play a song for you\" command = \"info\" args = {} assert command_handler_registry [ command ]( args ) == \"how can i help you?\" Instead of this, which violates the Open-Closed Principle (OCP): def info ( args ): return \"how can i help you?\" def play ( args ): return \"let me play a song for you\" def command_handler ( command , args ): if command == \"info\" : return info ( args ) if command == \"play\" : return play ( args ) command = \"play\" args = {} assert command_handler ( command , args ) == \"let me play a song for you\"","title":"TLDR"},{"location":"#installation","text":"You can install the latest version of registerer from PyPI: pip install registerer","title":"Installation"},{"location":"#features","text":"It's completely type-safe, thus you will get suggestions from your IDE. Writing custom validations for registered items is provided without any inheritance. generate choices for Django from registered items. And so on...","title":"Features"},{"location":"usage/","text":"Usage Installation You can install the latest version of registerer from PyPI: pip install registerer Usage In order to use registerer, you need to instantiate from the registerer.Registerer . There is several optional arguments you can pass to the Registerer constructor to manage how registry object should behave (Read more in reference section). Registering Classes import registerer class Animal : slug : str is_wild : bool def walk ( self ): pass animal_registry = registerer . Registerer ( # the registered item will only be sub-class of Animal. # this argument is necessary for type hints. parent_class = Animal , # only 5 items can be registered. max_size = 5 , # - set the slug of item as attribute on it. # - and also use the value of this attribute as slug if no # custom_slug passed to register method on registration. slug_attr = \"slug\" , validators = [ registerer . RegistryValidator ( lambda item : item . is_wild is False , # check passed if returns True error = \"can't register wild animal.\" , ), ], ) # Now with `animal_registry` you can register your classes: # use the name of class as unique identifier: @animal_registry . register () class Sheep ( Animal ): is_wild = False def walk ( self ): return \"sheep walks\" # use your custom slug as unique identifier: @animal_registry . register ( \"kitty\" ) class Cat ( Animal ): is_wild = False def walk ( self ): return \"cat walks\" assert animal_registry [ \"kitty\" ] == Cat assert animal_registry [ \"Sheep\" ]() . walk () == \"sheep walks\" assert animal_registry . items == [ Sheep , Cat ] assert Cat . slug == animal_registry [ \"kitty\" ] . slug == \"kitty\" # use this for django choices, etc. assert ( animal_registry . attrs_as_tuples ( \"slug\" , \"__name__\" ) == [( 'Sheep' , 'Sheep' ), ( 'kitty' , 'Cat' )] ) Registering Functions if you need to add attributes on the registered item on registration (it's optional), you can pass kwargs to the register method. This is useful when registering functions. for example: import registerer test_database_registry = registerer . Registerer ( validators = [ registerer . RegistryValidator ( lambda item : item . db_type == \"test\" , ), ] ) # use the name of function as unique identifier: @test_database_registry . register ( db_type = \"test\" ) def sqlite ( name : str ): return f \"sqlite connection { name } \" # use your custom slug as unique identifier: @test_database_registry . register ( \"postgresql\" , db_type = \"test\" ) def postgresql_test ( name : str ): return f \"postgresql connection { name } \" assert test_database_registry [ \"sqlite\" ]( \"quera\" ) == f \"sqlite connection quera\" assert test_database_registry [ \"postgresql\" ]( \"quera\" ) == f \"postgresql connection quera\" Notes The Slug Attribute The value of slug_attr passed to the Registerer is the name of a special attribute. As you know each item has it's unique identifier. Registerer will sync the registry identifier with this given attribute. When you are registering an item, the identifier slug could be on of these values (In order of preference): Custom slug: given to registry.register method as first positional argument. The value of given attribute by slug_attr . The name of item ( __name__ ). Choices For Django You may need to map the registered items to an object on Database. Having the items as choices on model field will help you with building admin and form choices. If you need to create choices for your model field, use registry.attrs_as_tuples method. For example: class EventStep ( models . Model ): _step_slug = models . CharField ( choices = registry . attrs_as_tuples ( \"slug\" , \"name\" ), max_length = 100 )","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#installation","text":"You can install the latest version of registerer from PyPI: pip install registerer","title":"Installation"},{"location":"usage/#usage_1","text":"In order to use registerer, you need to instantiate from the registerer.Registerer . There is several optional arguments you can pass to the Registerer constructor to manage how registry object should behave (Read more in reference section).","title":"Usage"},{"location":"usage/#registering-classes","text":"import registerer class Animal : slug : str is_wild : bool def walk ( self ): pass animal_registry = registerer . Registerer ( # the registered item will only be sub-class of Animal. # this argument is necessary for type hints. parent_class = Animal , # only 5 items can be registered. max_size = 5 , # - set the slug of item as attribute on it. # - and also use the value of this attribute as slug if no # custom_slug passed to register method on registration. slug_attr = \"slug\" , validators = [ registerer . RegistryValidator ( lambda item : item . is_wild is False , # check passed if returns True error = \"can't register wild animal.\" , ), ], ) # Now with `animal_registry` you can register your classes: # use the name of class as unique identifier: @animal_registry . register () class Sheep ( Animal ): is_wild = False def walk ( self ): return \"sheep walks\" # use your custom slug as unique identifier: @animal_registry . register ( \"kitty\" ) class Cat ( Animal ): is_wild = False def walk ( self ): return \"cat walks\" assert animal_registry [ \"kitty\" ] == Cat assert animal_registry [ \"Sheep\" ]() . walk () == \"sheep walks\" assert animal_registry . items == [ Sheep , Cat ] assert Cat . slug == animal_registry [ \"kitty\" ] . slug == \"kitty\" # use this for django choices, etc. assert ( animal_registry . attrs_as_tuples ( \"slug\" , \"__name__\" ) == [( 'Sheep' , 'Sheep' ), ( 'kitty' , 'Cat' )] )","title":"Registering Classes"},{"location":"usage/#registering-functions","text":"if you need to add attributes on the registered item on registration (it's optional), you can pass kwargs to the register method. This is useful when registering functions. for example: import registerer test_database_registry = registerer . Registerer ( validators = [ registerer . RegistryValidator ( lambda item : item . db_type == \"test\" , ), ] ) # use the name of function as unique identifier: @test_database_registry . register ( db_type = \"test\" ) def sqlite ( name : str ): return f \"sqlite connection { name } \" # use your custom slug as unique identifier: @test_database_registry . register ( \"postgresql\" , db_type = \"test\" ) def postgresql_test ( name : str ): return f \"postgresql connection { name } \" assert test_database_registry [ \"sqlite\" ]( \"quera\" ) == f \"sqlite connection quera\" assert test_database_registry [ \"postgresql\" ]( \"quera\" ) == f \"postgresql connection quera\"","title":"Registering Functions"},{"location":"usage/#notes","text":"","title":"Notes"},{"location":"usage/#the-slug-attribute","text":"The value of slug_attr passed to the Registerer is the name of a special attribute. As you know each item has it's unique identifier. Registerer will sync the registry identifier with this given attribute. When you are registering an item, the identifier slug could be on of these values (In order of preference): Custom slug: given to registry.register method as first positional argument. The value of given attribute by slug_attr . The name of item ( __name__ ).","title":"The Slug Attribute"},{"location":"usage/#choices-for-django","text":"You may need to map the registered items to an object on Database. Having the items as choices on model field will help you with building admin and form choices. If you need to create choices for your model field, use registry.attrs_as_tuples method. For example: class EventStep ( models . Model ): _step_slug = models . CharField ( choices = registry . attrs_as_tuples ( \"slug\" , \"name\" ), max_length = 100 )","title":"Choices For Django"},{"location":"references/exceptions/","text":"ItemNotRegistered Bases: Exception You've tried to get a item that is not registered. Source code in registerer/exceptions.py 9 10 class ItemNotRegistered ( Exception ): \"\"\"You've tried to get a item that is not registered.\"\"\" RegistrationError Bases: Exception Errors that occurs on registering new item. Source code in registerer/exceptions.py 5 6 class RegistrationError ( Exception ): \"\"\"Errors that occurs on registering new item.\"\"\" RegistryCreationError Bases: Exception Errors that occurs on creating a registry object. Source code in registerer/exceptions.py 1 2 class RegistryCreationError ( Exception ): \"\"\"Errors that occurs on creating a registry object.\"\"\"","title":"Exceptions"},{"location":"references/exceptions/#registerer.exceptions.ItemNotRegistered","text":"Bases: Exception You've tried to get a item that is not registered. Source code in registerer/exceptions.py 9 10 class ItemNotRegistered ( Exception ): \"\"\"You've tried to get a item that is not registered.\"\"\"","title":"ItemNotRegistered"},{"location":"references/exceptions/#registerer.exceptions.RegistrationError","text":"Bases: Exception Errors that occurs on registering new item. Source code in registerer/exceptions.py 5 6 class RegistrationError ( Exception ): \"\"\"Errors that occurs on registering new item.\"\"\"","title":"RegistrationError"},{"location":"references/exceptions/#registerer.exceptions.RegistryCreationError","text":"Bases: Exception Errors that occurs on creating a registry object. Source code in registerer/exceptions.py 1 2 class RegistryCreationError ( Exception ): \"\"\"Errors that occurs on creating a registry object.\"\"\"","title":"RegistryCreationError"},{"location":"references/registerer/","text":"Bases: typing . Generic [ T ] A utility that can be used to create a registry object to register class or functions. Source code in registerer/registry.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class Registerer ( typing . Generic [ T ]): \"\"\"A utility that can be used to create a registry object to register class or functions.\"\"\" def __init__ ( self , parent_class : typing . Optional [ typing . Type [ T ]] = None , * , slug_attr : typing . Optional [ str ] = None , max_size : typing . Optional [ int ] = None , validators : typing . Optional [ typing . List [ RegistryValidator ]] = None , ): \"\"\" Args: parent_class: The class of parent. If you set this, the registered class should be subclass of the this, If it's not the register method going to raise RegistrationError. Also by setting this you'll be benefit from type hints in your IDE. slug_attr: Pass the attribute name of registered item that you want to set registry slug to or read from registered item. max_size: allowed size of registered items. Defaults to None which means there is no limit. validators: custom validation for on registering items. Raises: RegistryCreationError: Can't create proper registry object. \"\"\" self . _registry_dict : typing . Dict [ str , typing . Type [ T ]] = {} self . parent_class : typing . Optional [ typing . Type [ T ]] = parent_class self . max_size : typing . Optional [ int ] = max_size self . slug_attr : typing . Optional [ str ] = slug_attr self . validators : typing . List = validators if validators else [] if self . max_size is not None and ( not isinstance ( self . max_size , int ) or self . max_size <= 0 ): raise RegistryCreationError ( \"max_size should be a int bigger than zero or None.\" ) for validator in self . validators : if not isinstance ( validator , RegistryValidator ): raise RegistryCreationError ( \"validator items should be object of RegistryValidator.\" ) @property def items ( self ) -> typing . List [ typing . Type [ T ]]: \"\"\" Get actual registered items as list (classes or functions) \"\"\" return list ( self . _registry_dict . values ()) def is_registered ( self , slug : str ) -> bool : \"\"\" Is the slug registered with any item? \"\"\" return slug in self . _registry_dict def __getitem__ ( self , registry_slug : str ) -> typing . Type [ T ]: \"\"\" get the registered item by slug \"\"\" try : return self . _registry_dict [ registry_slug ] except KeyError : raise ItemNotRegistered ( f \"The item with slug=' { registry_slug } ' is not registered.\" ) def get ( self , registry_slug : str , default : typing . Optional [ typing . Any ] = None ) -> typing . Optional [ typing . Type [ T ]]: \"\"\" Return the value for key if key is in the registry, else default. \"\"\" return self . _registry_dict . get ( registry_slug , default ) def validate ( self , item : typing . Type [ T ]): \"\"\"Validate the item during registration. Args: item (T): item want to register. Raises: RegistrationError: can't register this item. \"\"\" if self . parent_class is not None and inspect . isclass ( item ) and not issubclass ( item , self . parent_class ): raise RegistrationError ( f \"' { item . __name__ } ' class should be a subclass of ' { self . parent_class . __name__ } '.\" ) if inspect . isclass ( item ) and issubclass ( item , Registerer ): raise RegistrationError ( f \"Don't register a class inherited from Registerer. It's anti-pattern.\" ) if self . max_size is not None and len ( self . _registry_dict ) >= self . max_size : raise RegistrationError ( f \"You can't register more than { self . max_size } items to this registry.\" ) for validator in self . validators : validator ( item ) def register ( self , custom_slug : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Register a class or item to the registry example: ```python # register the item with it's name @registry.register() class Foo: pass assert registry[\"Foo\"] == Foo # register the item with a custom name @registry.register(\"bar\") class Bar: pass assert registry[\"bar\"] == Bar # register the item with a custom name and also add some other attributes to it. # it is more useful when registering functions. @db_registry.register(\"postgresql\", env=\"prod\") def postgresql_connection: pass assert registry[\"postgresql\"] == postgresql_connection assert postgresql_connection.env == \"prod\" ``` Args: custom_slug (str): the unique identifier for the item. Raises: ItemAlreadyRegistered: There is another item already registered with this slug. RegistrationError: can't register this item. \"\"\" def _wrapper_function ( item ): registry_slug = custom_slug or getattr ( item , self . slug_attr or \"\" , \"\" ) or item . __name__ if self . is_registered ( registry_slug ): raise RegistrationError ( f \"There is another item already registered with slug=' { registry_slug } '.\" ) if self . slug_attr : setattr ( item , self . slug_attr , registry_slug ) for key , value in kwargs . items (): setattr ( item , key , value ) self . validate ( item ) self . _registry_dict [ registry_slug ] = item return item return _wrapper_function def unregister ( self , registry_slug : str ) -> None : \"\"\" Unregister the item with given slug. \"\"\" try : self . _registry_dict . pop ( registry_slug ) except KeyError : raise ItemNotRegistered ( f \"The item with slug=' { registry_slug } ' is not registered.\" ) def filter ( self , function : typing . Callable [[ typing . Type [ T ]], bool ]) -> \"Registerer\" : \"\"\" Filter the registry with given callback and create another subset registry with desired items in it. \"\"\" registry = copy . deepcopy ( self ) registry . _registry_dict = { slug : item for slug , item in registry . _registry_dict . items () if function ( item )} return registry def attrs_as_tuples ( self , * args : str , flat : bool = False ) -> typing . List [ typing . Tuple ]: \"\"\" Returns list of tuples of based on attributes of registered items. You can use this to create choices for Django model field. Inspired by values_list in Django's QuerySet. ```python registry = registerer.Registerer() @registry.register() class ContestStep: slug = \"contest\" name = \"Contest\" @registry.register() class CollegeStep: slug = \"college\" name = \"College\" assert registry.attrs_as_tuples(\"slug\", \"name\") == [(\"contest\", \"Contest\"), (\"college\", \"College\")] assert registry.attrs_as_tuples(\"slug\", flat=True) == [\"contest\", \"college\"] class Step(django.db.models.Model): step_slug = models.CharField(max_length=100, choices=registry.attrs_as_tuples(\"slug\", \"name\")) ``` \"\"\" if not args : raise ValueError ( \"Select at least one attribute.\" ) if len ( args ) > 1 and flat : raise ValueError ( \"'flat' is not valid when attrs_as_tuples is called with more than one attribute.\" ) if flat : return [ getattr ( item , args [ 0 ]) for item in self . items ] return [ tuple ( getattr ( item , field ) for field in args ) for item in self . items ] def __repr__ ( self ) -> str : parent = f \" { self . parent_class . __name__ } \" if self . parent_class else \"\" count = f \"count= { len ( self . _registry_dict ) } \" return f \"< { parent } Registry { count } >\" items : typing . List [ typing . Type [ T ]] property Get actual registered items as list (classes or functions) __init__ ( parent_class = None , * , slug_attr = None , max_size = None , validators = None ) Parameters: Name Type Description Default parent_class typing . Optional [ typing . Type [ T ]] The class of parent. If you set this, the registered class should be subclass of the this, If it's not the register method going to raise RegistrationError. Also by setting this you'll be benefit from type hints in your IDE. None slug_attr typing . Optional [ str ] Pass the attribute name of registered item that you want to set registry slug to or read from registered item. None max_size typing . Optional [ int ] allowed size of registered items. Defaults to None which means there is no limit. None validators typing . Optional [ typing . List [ RegistryValidator ]] custom validation for on registering items. None Raises: Type Description RegistryCreationError Can't create proper registry object. Source code in registerer/registry.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , parent_class : typing . Optional [ typing . Type [ T ]] = None , * , slug_attr : typing . Optional [ str ] = None , max_size : typing . Optional [ int ] = None , validators : typing . Optional [ typing . List [ RegistryValidator ]] = None , ): \"\"\" Args: parent_class: The class of parent. If you set this, the registered class should be subclass of the this, If it's not the register method going to raise RegistrationError. Also by setting this you'll be benefit from type hints in your IDE. slug_attr: Pass the attribute name of registered item that you want to set registry slug to or read from registered item. max_size: allowed size of registered items. Defaults to None which means there is no limit. validators: custom validation for on registering items. Raises: RegistryCreationError: Can't create proper registry object. \"\"\" self . _registry_dict : typing . Dict [ str , typing . Type [ T ]] = {} self . parent_class : typing . Optional [ typing . Type [ T ]] = parent_class self . max_size : typing . Optional [ int ] = max_size self . slug_attr : typing . Optional [ str ] = slug_attr self . validators : typing . List = validators if validators else [] if self . max_size is not None and ( not isinstance ( self . max_size , int ) or self . max_size <= 0 ): raise RegistryCreationError ( \"max_size should be a int bigger than zero or None.\" ) for validator in self . validators : if not isinstance ( validator , RegistryValidator ): raise RegistryCreationError ( \"validator items should be object of RegistryValidator.\" ) is_registered ( slug ) Is the slug registered with any item? Source code in registerer/registry.py 57 58 59 60 61 def is_registered ( self , slug : str ) -> bool : \"\"\" Is the slug registered with any item? \"\"\" return slug in self . _registry_dict __getitem__ ( registry_slug ) get the registered item by slug Source code in registerer/registry.py 63 64 65 66 67 68 69 70 def __getitem__ ( self , registry_slug : str ) -> typing . Type [ T ]: \"\"\" get the registered item by slug \"\"\" try : return self . _registry_dict [ registry_slug ] except KeyError : raise ItemNotRegistered ( f \"The item with slug=' { registry_slug } ' is not registered.\" ) get ( registry_slug , default = None ) Return the value for key if key is in the registry, else default. Source code in registerer/registry.py 72 73 74 75 76 def get ( self , registry_slug : str , default : typing . Optional [ typing . Any ] = None ) -> typing . Optional [ typing . Type [ T ]]: \"\"\" Return the value for key if key is in the registry, else default. \"\"\" return self . _registry_dict . get ( registry_slug , default ) validate ( item ) Validate the item during registration. Parameters: Name Type Description Default item T item want to register. required Raises: Type Description RegistrationError can't register this item. Source code in registerer/registry.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def validate ( self , item : typing . Type [ T ]): \"\"\"Validate the item during registration. Args: item (T): item want to register. Raises: RegistrationError: can't register this item. \"\"\" if self . parent_class is not None and inspect . isclass ( item ) and not issubclass ( item , self . parent_class ): raise RegistrationError ( f \"' { item . __name__ } ' class should be a subclass of ' { self . parent_class . __name__ } '.\" ) if inspect . isclass ( item ) and issubclass ( item , Registerer ): raise RegistrationError ( f \"Don't register a class inherited from Registerer. It's anti-pattern.\" ) if self . max_size is not None and len ( self . _registry_dict ) >= self . max_size : raise RegistrationError ( f \"You can't register more than { self . max_size } items to this registry.\" ) for validator in self . validators : validator ( item ) register ( custom_slug = None , ** kwargs ) Register a class or item to the registry example: # register the item with it's name @registry . register () class Foo : pass assert registry [ \"Foo\" ] == Foo # register the item with a custom name @registry . register ( \"bar\" ) class Bar : pass assert registry [ \"bar\" ] == Bar # register the item with a custom name and also add some other attributes to it. # it is more useful when registering functions. @db_registry . register ( \"postgresql\" , env = \"prod\" ) def postgresql_connection : pass assert registry [ \"postgresql\" ] == postgresql_connection assert postgresql_connection . env == \"prod\" Parameters: Name Type Description Default custom_slug str the unique identifier for the item. None Raises: Type Description ItemAlreadyRegistered There is another item already registered with this slug. RegistrationError can't register this item. Source code in registerer/registry.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def register ( self , custom_slug : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Register a class or item to the registry example: ```python # register the item with it's name @registry.register() class Foo: pass assert registry[\"Foo\"] == Foo # register the item with a custom name @registry.register(\"bar\") class Bar: pass assert registry[\"bar\"] == Bar # register the item with a custom name and also add some other attributes to it. # it is more useful when registering functions. @db_registry.register(\"postgresql\", env=\"prod\") def postgresql_connection: pass assert registry[\"postgresql\"] == postgresql_connection assert postgresql_connection.env == \"prod\" ``` Args: custom_slug (str): the unique identifier for the item. Raises: ItemAlreadyRegistered: There is another item already registered with this slug. RegistrationError: can't register this item. \"\"\" def _wrapper_function ( item ): registry_slug = custom_slug or getattr ( item , self . slug_attr or \"\" , \"\" ) or item . __name__ if self . is_registered ( registry_slug ): raise RegistrationError ( f \"There is another item already registered with slug=' { registry_slug } '.\" ) if self . slug_attr : setattr ( item , self . slug_attr , registry_slug ) for key , value in kwargs . items (): setattr ( item , key , value ) self . validate ( item ) self . _registry_dict [ registry_slug ] = item return item return _wrapper_function unregister ( registry_slug ) Unregister the item with given slug. Source code in registerer/registry.py 158 159 160 161 162 163 164 165 def unregister ( self , registry_slug : str ) -> None : \"\"\" Unregister the item with given slug. \"\"\" try : self . _registry_dict . pop ( registry_slug ) except KeyError : raise ItemNotRegistered ( f \"The item with slug=' { registry_slug } ' is not registered.\" ) filter ( function ) Filter the registry with given callback and create another subset registry with desired items in it. Source code in registerer/registry.py 167 168 169 170 171 172 173 174 def filter ( self , function : typing . Callable [[ typing . Type [ T ]], bool ]) -> \"Registerer\" : \"\"\" Filter the registry with given callback and create another subset registry with desired items in it. \"\"\" registry = copy . deepcopy ( self ) registry . _registry_dict = { slug : item for slug , item in registry . _registry_dict . items () if function ( item )} return registry attrs_as_tuples ( * args , flat = False ) Returns list of tuples of based on attributes of registered items. You can use this to create choices for Django model field. Inspired by values_list in Django's QuerySet. registry = registerer . Registerer () @registry . register () class ContestStep : slug = \"contest\" name = \"Contest\" @registry . register () class CollegeStep : slug = \"college\" name = \"College\" assert registry . attrs_as_tuples ( \"slug\" , \"name\" ) == [( \"contest\" , \"Contest\" ), ( \"college\" , \"College\" )] assert registry . attrs_as_tuples ( \"slug\" , flat = True ) == [ \"contest\" , \"college\" ] class Step ( django . db . models . Model ): step_slug = models . CharField ( max_length = 100 , choices = registry . attrs_as_tuples ( \"slug\" , \"name\" )) Source code in registerer/registry.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def attrs_as_tuples ( self , * args : str , flat : bool = False ) -> typing . List [ typing . Tuple ]: \"\"\" Returns list of tuples of based on attributes of registered items. You can use this to create choices for Django model field. Inspired by values_list in Django's QuerySet. ```python registry = registerer.Registerer() @registry.register() class ContestStep: slug = \"contest\" name = \"Contest\" @registry.register() class CollegeStep: slug = \"college\" name = \"College\" assert registry.attrs_as_tuples(\"slug\", \"name\") == [(\"contest\", \"Contest\"), (\"college\", \"College\")] assert registry.attrs_as_tuples(\"slug\", flat=True) == [\"contest\", \"college\"] class Step(django.db.models.Model): step_slug = models.CharField(max_length=100, choices=registry.attrs_as_tuples(\"slug\", \"name\")) ``` \"\"\" if not args : raise ValueError ( \"Select at least one attribute.\" ) if len ( args ) > 1 and flat : raise ValueError ( \"'flat' is not valid when attrs_as_tuples is called with more than one attribute.\" ) if flat : return [ getattr ( item , args [ 0 ]) for item in self . items ] return [ tuple ( getattr ( item , field ) for field in args ) for item in self . items ]","title":"Registerer"},{"location":"references/registerer/#registerer.registry.Registerer.items","text":"Get actual registered items as list (classes or functions)","title":"items"},{"location":"references/registerer/#registerer.registry.Registerer.__init__","text":"Parameters: Name Type Description Default parent_class typing . Optional [ typing . Type [ T ]] The class of parent. If you set this, the registered class should be subclass of the this, If it's not the register method going to raise RegistrationError. Also by setting this you'll be benefit from type hints in your IDE. None slug_attr typing . Optional [ str ] Pass the attribute name of registered item that you want to set registry slug to or read from registered item. None max_size typing . Optional [ int ] allowed size of registered items. Defaults to None which means there is no limit. None validators typing . Optional [ typing . List [ RegistryValidator ]] custom validation for on registering items. None Raises: Type Description RegistryCreationError Can't create proper registry object. Source code in registerer/registry.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , parent_class : typing . Optional [ typing . Type [ T ]] = None , * , slug_attr : typing . Optional [ str ] = None , max_size : typing . Optional [ int ] = None , validators : typing . Optional [ typing . List [ RegistryValidator ]] = None , ): \"\"\" Args: parent_class: The class of parent. If you set this, the registered class should be subclass of the this, If it's not the register method going to raise RegistrationError. Also by setting this you'll be benefit from type hints in your IDE. slug_attr: Pass the attribute name of registered item that you want to set registry slug to or read from registered item. max_size: allowed size of registered items. Defaults to None which means there is no limit. validators: custom validation for on registering items. Raises: RegistryCreationError: Can't create proper registry object. \"\"\" self . _registry_dict : typing . Dict [ str , typing . Type [ T ]] = {} self . parent_class : typing . Optional [ typing . Type [ T ]] = parent_class self . max_size : typing . Optional [ int ] = max_size self . slug_attr : typing . Optional [ str ] = slug_attr self . validators : typing . List = validators if validators else [] if self . max_size is not None and ( not isinstance ( self . max_size , int ) or self . max_size <= 0 ): raise RegistryCreationError ( \"max_size should be a int bigger than zero or None.\" ) for validator in self . validators : if not isinstance ( validator , RegistryValidator ): raise RegistryCreationError ( \"validator items should be object of RegistryValidator.\" )","title":"__init__()"},{"location":"references/registerer/#registerer.registry.Registerer.is_registered","text":"Is the slug registered with any item? Source code in registerer/registry.py 57 58 59 60 61 def is_registered ( self , slug : str ) -> bool : \"\"\" Is the slug registered with any item? \"\"\" return slug in self . _registry_dict","title":"is_registered()"},{"location":"references/registerer/#registerer.registry.Registerer.__getitem__","text":"get the registered item by slug Source code in registerer/registry.py 63 64 65 66 67 68 69 70 def __getitem__ ( self , registry_slug : str ) -> typing . Type [ T ]: \"\"\" get the registered item by slug \"\"\" try : return self . _registry_dict [ registry_slug ] except KeyError : raise ItemNotRegistered ( f \"The item with slug=' { registry_slug } ' is not registered.\" )","title":"__getitem__()"},{"location":"references/registerer/#registerer.registry.Registerer.get","text":"Return the value for key if key is in the registry, else default. Source code in registerer/registry.py 72 73 74 75 76 def get ( self , registry_slug : str , default : typing . Optional [ typing . Any ] = None ) -> typing . Optional [ typing . Type [ T ]]: \"\"\" Return the value for key if key is in the registry, else default. \"\"\" return self . _registry_dict . get ( registry_slug , default )","title":"get()"},{"location":"references/registerer/#registerer.registry.Registerer.validate","text":"Validate the item during registration. Parameters: Name Type Description Default item T item want to register. required Raises: Type Description RegistrationError can't register this item. Source code in registerer/registry.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def validate ( self , item : typing . Type [ T ]): \"\"\"Validate the item during registration. Args: item (T): item want to register. Raises: RegistrationError: can't register this item. \"\"\" if self . parent_class is not None and inspect . isclass ( item ) and not issubclass ( item , self . parent_class ): raise RegistrationError ( f \"' { item . __name__ } ' class should be a subclass of ' { self . parent_class . __name__ } '.\" ) if inspect . isclass ( item ) and issubclass ( item , Registerer ): raise RegistrationError ( f \"Don't register a class inherited from Registerer. It's anti-pattern.\" ) if self . max_size is not None and len ( self . _registry_dict ) >= self . max_size : raise RegistrationError ( f \"You can't register more than { self . max_size } items to this registry.\" ) for validator in self . validators : validator ( item )","title":"validate()"},{"location":"references/registerer/#registerer.registry.Registerer.register","text":"Register a class or item to the registry example: # register the item with it's name @registry . register () class Foo : pass assert registry [ \"Foo\" ] == Foo # register the item with a custom name @registry . register ( \"bar\" ) class Bar : pass assert registry [ \"bar\" ] == Bar # register the item with a custom name and also add some other attributes to it. # it is more useful when registering functions. @db_registry . register ( \"postgresql\" , env = \"prod\" ) def postgresql_connection : pass assert registry [ \"postgresql\" ] == postgresql_connection assert postgresql_connection . env == \"prod\" Parameters: Name Type Description Default custom_slug str the unique identifier for the item. None Raises: Type Description ItemAlreadyRegistered There is another item already registered with this slug. RegistrationError can't register this item. Source code in registerer/registry.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def register ( self , custom_slug : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Register a class or item to the registry example: ```python # register the item with it's name @registry.register() class Foo: pass assert registry[\"Foo\"] == Foo # register the item with a custom name @registry.register(\"bar\") class Bar: pass assert registry[\"bar\"] == Bar # register the item with a custom name and also add some other attributes to it. # it is more useful when registering functions. @db_registry.register(\"postgresql\", env=\"prod\") def postgresql_connection: pass assert registry[\"postgresql\"] == postgresql_connection assert postgresql_connection.env == \"prod\" ``` Args: custom_slug (str): the unique identifier for the item. Raises: ItemAlreadyRegistered: There is another item already registered with this slug. RegistrationError: can't register this item. \"\"\" def _wrapper_function ( item ): registry_slug = custom_slug or getattr ( item , self . slug_attr or \"\" , \"\" ) or item . __name__ if self . is_registered ( registry_slug ): raise RegistrationError ( f \"There is another item already registered with slug=' { registry_slug } '.\" ) if self . slug_attr : setattr ( item , self . slug_attr , registry_slug ) for key , value in kwargs . items (): setattr ( item , key , value ) self . validate ( item ) self . _registry_dict [ registry_slug ] = item return item return _wrapper_function","title":"register()"},{"location":"references/registerer/#registerer.registry.Registerer.unregister","text":"Unregister the item with given slug. Source code in registerer/registry.py 158 159 160 161 162 163 164 165 def unregister ( self , registry_slug : str ) -> None : \"\"\" Unregister the item with given slug. \"\"\" try : self . _registry_dict . pop ( registry_slug ) except KeyError : raise ItemNotRegistered ( f \"The item with slug=' { registry_slug } ' is not registered.\" )","title":"unregister()"},{"location":"references/registerer/#registerer.registry.Registerer.filter","text":"Filter the registry with given callback and create another subset registry with desired items in it. Source code in registerer/registry.py 167 168 169 170 171 172 173 174 def filter ( self , function : typing . Callable [[ typing . Type [ T ]], bool ]) -> \"Registerer\" : \"\"\" Filter the registry with given callback and create another subset registry with desired items in it. \"\"\" registry = copy . deepcopy ( self ) registry . _registry_dict = { slug : item for slug , item in registry . _registry_dict . items () if function ( item )} return registry","title":"filter()"},{"location":"references/registerer/#registerer.registry.Registerer.attrs_as_tuples","text":"Returns list of tuples of based on attributes of registered items. You can use this to create choices for Django model field. Inspired by values_list in Django's QuerySet. registry = registerer . Registerer () @registry . register () class ContestStep : slug = \"contest\" name = \"Contest\" @registry . register () class CollegeStep : slug = \"college\" name = \"College\" assert registry . attrs_as_tuples ( \"slug\" , \"name\" ) == [( \"contest\" , \"Contest\" ), ( \"college\" , \"College\" )] assert registry . attrs_as_tuples ( \"slug\" , flat = True ) == [ \"contest\" , \"college\" ] class Step ( django . db . models . Model ): step_slug = models . CharField ( max_length = 100 , choices = registry . attrs_as_tuples ( \"slug\" , \"name\" )) Source code in registerer/registry.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def attrs_as_tuples ( self , * args : str , flat : bool = False ) -> typing . List [ typing . Tuple ]: \"\"\" Returns list of tuples of based on attributes of registered items. You can use this to create choices for Django model field. Inspired by values_list in Django's QuerySet. ```python registry = registerer.Registerer() @registry.register() class ContestStep: slug = \"contest\" name = \"Contest\" @registry.register() class CollegeStep: slug = \"college\" name = \"College\" assert registry.attrs_as_tuples(\"slug\", \"name\") == [(\"contest\", \"Contest\"), (\"college\", \"College\")] assert registry.attrs_as_tuples(\"slug\", flat=True) == [\"contest\", \"college\"] class Step(django.db.models.Model): step_slug = models.CharField(max_length=100, choices=registry.attrs_as_tuples(\"slug\", \"name\")) ``` \"\"\" if not args : raise ValueError ( \"Select at least one attribute.\" ) if len ( args ) > 1 and flat : raise ValueError ( \"'flat' is not valid when attrs_as_tuples is called with more than one attribute.\" ) if flat : return [ getattr ( item , args [ 0 ]) for item in self . items ] return [ tuple ( getattr ( item , field ) for field in args ) for item in self . items ]","title":"attrs_as_tuples()"},{"location":"references/validators/","text":"RegistryValidator a utility for custom validation with the Registerer. you can subclass this and override the on_register method, and raise an exception if you must. Source code in registerer/validators.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class RegistryValidator : \"\"\" a utility for custom validation with the Registerer. you can subclass this and override the on_register method, and raise an exception if you must. \"\"\" def __init__ ( self , validator , * , error : typing . Optional [ str ] = None ) -> None : self . validator = validator self . error = error def __call__ ( self , item ): \"\"\" this function will be called when registering an item args: item (Any): the item that is being registered (the class or function) \"\"\" if not self . validator ( item ): raise RegistrationError ( self . error if self . error else f \"custom validation failed when registering { item . __name__ } \" ) __call__ ( item ) this function will be called when registering an item Parameters: Name Type Description Default item Any the item that is being registered (the class or function) required Source code in registerer/validators.py 17 18 19 20 21 22 23 24 25 26 27 def __call__ ( self , item ): \"\"\" this function will be called when registering an item args: item (Any): the item that is being registered (the class or function) \"\"\" if not self . validator ( item ): raise RegistrationError ( self . error if self . error else f \"custom validation failed when registering { item . __name__ } \" )","title":"Validators"},{"location":"references/validators/#registerer.validators.RegistryValidator","text":"a utility for custom validation with the Registerer. you can subclass this and override the on_register method, and raise an exception if you must. Source code in registerer/validators.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class RegistryValidator : \"\"\" a utility for custom validation with the Registerer. you can subclass this and override the on_register method, and raise an exception if you must. \"\"\" def __init__ ( self , validator , * , error : typing . Optional [ str ] = None ) -> None : self . validator = validator self . error = error def __call__ ( self , item ): \"\"\" this function will be called when registering an item args: item (Any): the item that is being registered (the class or function) \"\"\" if not self . validator ( item ): raise RegistrationError ( self . error if self . error else f \"custom validation failed when registering { item . __name__ } \" )","title":"RegistryValidator"},{"location":"references/validators/#registerer.validators.RegistryValidator.__call__","text":"this function will be called when registering an item Parameters: Name Type Description Default item Any the item that is being registered (the class or function) required Source code in registerer/validators.py 17 18 19 20 21 22 23 24 25 26 27 def __call__ ( self , item ): \"\"\" this function will be called when registering an item args: item (Any): the item that is being registered (the class or function) \"\"\" if not self . validator ( item ): raise RegistrationError ( self . error if self . error else f \"custom validation failed when registering { item . __name__ } \" )","title":"__call__()"}]}